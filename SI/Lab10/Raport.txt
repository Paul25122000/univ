Explicatii:
Task1: 
 Poate fi obervat în imaginea 0_config.png

Tind să mentionez că flagurile "-z execstack" și -fno-stack-protector au fost setate.
Însă programul exemplu "call_shellcode" rezultă în "segmentation fault"

Task2:
Domnul indian de pe YT mi-a sugerat să scad din ebp adresa tamponului ($ebp-&buffer)
Absurditate totală, căci $ebp este (în cazul meu) -8816, iar &buffer este 0x7fffffffdd60.
Această scădere nu poate fi realizată (int și poitner). Dar nici nu imi dă ceva informație relevantă.

Scăzând, însă, din pointerul la adresa de return pointerul la adresa tamponului
obținem date utile, și anume: spațiul dintre rpb si buffer cu tot cu gap înclus.
Cunoscând aceste date, putem spune unde trebuie înscrisă adresa de return în tampon.
Calculul aferent este: 0x7fffffffdd90 - 0x7fffffffdd70 = 0x20 = 32 în zecimal. 

Din aceasta reese, că prima adresă disponibilă pentru utilizare este:
	rbp + 4(Prevoius Frame Pointer) + 4(Return Pointer) = 0x7fffffffdd98
Mai usor insa e sa verificam campul "rip", utilizand în GDB instruncțiunea "info frame", cum se poate veadea in screenshot-ul 3_buffer_and_rip.png.
Și ar trebui sa ne fie disponibilă, căci spațiul alocat pentru *str a fost suprascris.

Dacă să încercam adresa 0x7fffffffe090, care depaseste zona în care am inserat codul,
constatăm ca nu mai exista instructiuni valide.

